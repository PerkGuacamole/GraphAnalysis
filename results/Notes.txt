March 24th 2021

    Ran tests for page rank with explicit vectorization on neighbors versus v2, where the compiler vectoizes on page rank matrix.
    Seems that mine is faster for lower number of page ranks, and the compiler's version is better for higher number of page ranks.
    Action:
    	Use the compiler version
    	Also switching from static to dynamic scheduling

March 27th 2021

    Page Rank Results:
        I looked at the results for running page rank with the compiler.
        The results for lower page ranks performed worse than my implementation.
        My implementation, might actually have been better for DRAM, but worse for PMEM.
        So the compilers version might be better for PMEM, so I might have to seperate these.

    BFS is way too slow:
        std::atomic, might have to use this instead of using OMP critical

April 4th 2021

    Page Rank Results:
        I ran my version of page rank again for all graphs
    
    BFS:
        std::atmoic didn't work, but making a mutex for every element did

    GraphCRS:
        I'm think about adding an extra element to the row_ind array so that I don't have to check if I'm inspecting the last element
        It should make the code much easier to read and write, also removing a if statement in critical spots in the code.

April 6th 2021

    Page Rank:
        Try "#pragma omp simd"
        Rerun, PR wasn't being changed
    
    Hyperthreading:
        Use 18 threads instead
        Compare hyperthread to no hyperthread
            If latency is higher, maybe more concurrency is good

    Conclusion:
        Think of recommendations
        Is this even useful?
        Can there be even more performance?

April 9th 2021

    Page Rank:
        Rank again for 32 and 64
        Use my version, can also do 36vs18 threads
        Use Line charts instead
    
    BFS:
        Need to understand more
        Run again, time using only Top-Down and Bottom-Up
        See if the graphs looks like the one from the paper
        DD & PP only

    OMP_PLACES:
        'threads' and 'cores' options work as described
        We don't use hyperthreading
        Orkut is the only graph which does better with hyperthreading
    
    OMP_PROC_BIND:
        'true' vs 'close' seem to be the same
        